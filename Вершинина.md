## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Репозитории и тикеты:
 - репозиторий может иметь несколько тикетов
 - тикет может принадлежать только одному репозиторию
 - репозиторий - название, описание, количество звезд
 - тикет - название, описание, статус

### 2. Фестивали и выступления:
- фестиваль может иметь несколько выступлений
- выступление может принадлежать только одному фестивалю
- фестиваль - название, дата, место
- выступление - название, дата, жанр

### 3. Учебные заведения и группы:
- в учебном заведении может быть много групп
- группа может принадлежать только одному учебному заведению
- учебное заведение - название, адрес
- группа - название, программа обучения, год начала обучения

## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы

-- Репозитории и тикеты:
-- репозиторий может иметь несколько тикетов
-- тикет может принадлежать только одному репозиторию
-- репозиторий - название, описание, количество звезд
-- тикет - название, описание, статус
-- Для каждого примера сделать вывод связанных сущностей (за один запрос)
-- зависимая сущность должна быть представлена в виде массива объектов
-- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
-- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
-- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы


drop table if exists repozitoris, tikets cascade;

create table repozitoris 
(
	id int primary key,
	name_repozitoris text,
	text_repozitoris text,
	stars int
);

create table tikets 
(
	id int primary key,
	name_tikets text,
	text_tikets text,
	status text,
	repozitoris_id int references repozitoris
);

insert into repozitoris(id, name_repozitoris, text_repozitoris, stars)
values(1, 'Cop', 'The best', 4),
	  (2, 'Non', 'Good', 5),
	  (3, 'Wew', 'Bad', 2);
	  
insert into tikets(id, name_tikets, text_tikets, status, id_repozitoris)
values(1, 'yt', 'good', '01', 1),
	  (2, 'ret', 'good', '03', 2),
	  (3, 'hew', 'best', '67', 1),
	  (4, 'poi', 'best', '34', 2),
	  (5, 'xcd', 'bad', '22', 3);
	  

select
	r.id as repozitoris_id,
	r.name_repozitoris,
	r.text_repozitoris,
	r.stars,
	coalesce(jsonb_agg(jsonb_build_object(
	'id', t.id, 'name_tikets', t.name_tikets, 'text_tikets', t.text_tikets, 'status', t.status))
		filter (where t.id is not null), '[]') as tikets
from repozitoris
left join tikets t on r.id = t.repozitoris_id
group by r.id;
	


-- Фестивали и выступления:
-- фестиваль может иметь несколько выступлений
-- выступление может принадлежать только одному фестивалю
-- фестиваль - название, дата, место
-- выступление - название, дата, жанр

drop table if exists fests, perfomences cascade;

create table fests
(
	id int primary key,
	name_fest text,
	date_fest date,
	place text
);

create table perfomences
(
	id int primary key,
	name_perfomence text,
	date_perfomence date,
	genre text,
	perfomnce_id int references fests
);

insert into fests(id, name_fest, date_fest, place)
values
(1, 'WFM', '2024-02-02', 'Сириус'),
(2, 'Moсква-2023', '2024-04-04', 'Москва'),
(3, 'Санкт-Петербург-2025', '2022-05-02', 'Санкт-Петербург');

insert into perfomences(id, name_perfomence, date_perfomence, genre, perfomence_id)
values
(1, 'Ytr', '2024-02-02', 'научпоп', 1),
(2, 'pOP', '2024-02-02', 'рок', 1),
(3, 'tyt', '2024-04-04', 'фанастика', 2),
(4, 'ret', '2022-05-02', 'рок', 3);


select
	p.id as perfomence_id,
	p.name_perfomence,
	p.date_perfomance,
	p.genre,
	coalesce(jsonb_agg(jsonb_build_array(
	'id', f.id, 'name_fest', f.name_fest, 'date_fest', f.date_fest, 'place', f.place))
		filter (where f.id is not null), '[]') as fests
from fests f
left join fests f on f,id = f.perfomences_id
group by f.id;

drop table if exists studys, groupss cascade;

create table studys
(
	id int primary key,
	name_studys text,
	adress text
);

create table groupss
(
	id int primary key,
	name_group text,
	programm text,
	year_start int,
	studys_id int references studys
);

insert into studys(id, name_studys, adress)
values
(1, 'СПБГУ', 'ул Маяковского 1'),
(2, 'МАИ', 'ул Ленина 3'),
(3, 'Сириус', 'пр Олимпийский 1');

insert into groupss(id, name_group, programm, year_start, studys_id)
values
(1, 'К0711-23', 'Информационные технологии', 2023, 3),
(2, 'К0709-22/1', 'Информационные технологии', 2022, 3),
(3, 'Б22/22', 'Биология', 2022, 1),
(4, 'Б13/21', 'Химия', 2021, 2);

select 
	st.id as studys_id,
	st.name_studys,
	st.adress,
	coalesce(jsonb_agg(jsonb_build_object(
	'id', gr.id, 'name_group', gr.name_group, 'programm', gr.programm, 'year_start', gr.year_start, 'studys_id', gr.studys_id))
		filter (where gr.id is not null), '[]') as groupss

from studys st
left join groupss gr on st.id = gr.studys_id
group by st.id;

